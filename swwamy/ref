"""===========================================================================
DESCRIPTION:  Standard Repo for DATS_BBG_REQUEST

AUTHOR:       Generated by DA AutoGen (PIMCO\josung)

DATE:         Jul  3 2018 10:03AM
===========================================================================
"""
from itertools import izip_longest
from sqlalchemy import update, func, and_, or_
from sqlalchemy.sql.operators import isnot, is_
from .gen.dats_bbg_request import DatsBbgRequestRepo as GenDatsBbgRequestRepo


class DatsBbgRequestRepo(GenDatsBbgRequestRepo):
    """Custom routines
    For example:
    from .foo import LifeRepo
    def get_my_answer(self):
        Life = LifeRepo(self.db)
        return self.db.query(self.model, Life).\
            join(Life, self.model.meaning == Life.meaning).\
            filter(self.model.answer == 42)
    """

    def list_by_ticker_yellow_mnemonic_tag_list(self, series):
        ands = [and_(self.model.req_ticker == sec.ticker,
                     self.model.req_yellow_key == sec.yellow_key,
                     self.model.req_mnemonic == sec.mnemonic,
                     self.model.req_bbg_interface_code == sec.interface)
                for sec in series]
        in_clause = and_(or_(*ands),
                         self.model.dats_bbg_request_status_code.in_(
                             ['NEW']))
        return self.query.with_entities(self.model.req_ticker,
                                        self.model.req_yellow_key,
                                        self.model.req_mnemonic,
                                        self.model.req_bbg_interface_code
                                        ).filter(in_clause).distinct().all()

    def list_by_dats_bbg_request_status_code_limit_no_ps(self, status_code, num):
        return self.query.filter(
            self.model.dats_bbg_request_status_code == status_code,
            self.model.req_pricing_source.is_(None)
        ).order_by(
            self.model.row_insert_date.asc()
        ).limit(num)

    def list_by_dats_bbg_request_status_code_limit_has_ps(self, status_code, num):
        return self.query.filter(
            self.model.dats_bbg_request_status_code == status_code,
            self.model.req_pricing_source.isnot(None)
        ).order_by(
            self.model.row_insert_date.asc()
        ).limit(num)

    def list_by_dats_bbg_request_status_code_register_series(self, dats_bbg_request_status_code):
        return self.query.filter(
            self.model.dats_bbg_request_status_code == dats_bbg_request_status_code,
            self.model.req_is_register_series == 1).all()

    def list_by_bt_request_id(self, status_code, limit):
        s = self.query \
            .filter(self.model.dats_bbg_request_status_code == status_code) \
            .with_entities(self.model.bt_request_id) \
            .distinct(self.model.bt_request_id) \
            .order_by(self.model.bt_request_id.asc()) \
            .limit(limit) \
            .subquery('s')
        return self.query.filter(self.model.bt_request_id == s.c.bt_request_id)

    def update_for_dats_bbg_request_id(self, dats_bbg_request_id, **kwargs):
        row = self.get_by_dats_bbg_request_id(dats_bbg_request_id)
        return row if not row else self.save(update(row, **kwargs))

    def update_all(self, dats_bbg_requests):
        self.db.session.bulk_update_mappings(self.model, dats_bbg_requests)
        self.db.session.flush()
        self.db.session.commit()

    def update(self, request_ids, status_to, bt_request_id, public_msg):
        for r in izip_longest(*(iter(request_ids),) * 1000):
            request_query = self.query.filter(
                self.model.dats_bbg_request_id.in_(r))
            update_data = {
                self.model.dats_bbg_request_status_code: status_to.value,
                self.model.row_update_by: self.db.user,
                self.model.row_update_date: func.now()
            }
            if bt_request_id:
                update_data.update({
                    self.model.bt_request_id: bt_request_id
                })
            if public_msg:
                update_data.update({
                    self.model.public_msg: public_msg
                })
            sq = request_query \
                .with_entities(self.model.dats_bbg_request_id) \
                .with_for_update()
            self.db.session.execute(
                update(self.model).
                values(update_data).
                where(self.model.dats_bbg_request_id.in_(sq.as_scalar()))
            )
            self.db.session.commit()

    def save_bulk(self, data):
        self.db.session.bulk_insert_mappings(self.model, data)
        self.db.session.commit()

        return self.query.filter(self.model.dats_bbg_request_guid.in_(
            [g['dats_bbg_request_guid'] for g in data]
        )).all()

    def get_by_req_tag(self, req_tag):
        return self.query.filter(self.model.req_tag == req_tag).all()
